/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.
    
Environment:

    Kernel-mode Driver Framework

--*/

#include "driver.h"
#include "device.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, DTMouseDriverCreateDevice)
#endif

ULONG InstanceNo = 0;

NTSTATUS MouseEvtDeviceSelfManagedIoInit(
	IN WDFDEVICE Device
)
{
	UNREFERENCED_PARAMETER(Device);
	return 0;
}


NTSTATUS MouseEvtDeviceSelfManagedIoCleanup(
	IN WDFDEVICE Device
)
{
	//PDEVICE_CONTEXT deviceContext;
	UNREFERENCED_PARAMETER(Device);
	//deviceContext = DeviceGetContext(Device);
	//KeCancelTimer(&deviceContext->ServiceTme);
	return 0;
}


VOID MouseEvtFileClose(
	_In_ WDFFILEOBJECT FileObject
)
{
	UNREFERENCED_PARAMETER(FileObject);
	//WDFDEVICE     Device=WdfFileObjectGetDevice(FileObject);
	
	//
	// It's fine for the device to be powered off if there are no open handles.
	//
	//WdfDeviceResumeIdle(Device);

	//WdfDeviceSetStaticStopRemove(Device, TRUE);

}

VOID MouseEvtFileCleanup(
	_In_ WDFFILEOBJECT FileObject
)
{
	UNREFERENCED_PARAMETER(FileObject);
}

VOID MouseEvtDeviceFileCreate(
	_In_ WDFDEVICE     Device,
	_In_ WDFREQUEST    Request,
	_In_ WDFFILEOBJECT FileObject
)
{
	NTSTATUS status=STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(Device);
	UNREFERENCED_PARAMETER(FileObject);

	// By taking a power reference by calling WdfDeviceStopIdle, we prevent the
	// framework from powering down our device due to idle timeout when there
	// is an open handle.  Power reference also moves the device to D0 if we are
	// idled out. If you fail create anywhere later in this routine, do make sure
	// drop the reference.
//	status = WdfDeviceStopIdle(Device, TRUE);

	
	// We don't want the device to be removed or stopped when there is an handle
	//
	// Note to anyone copying this sample as a starting point:
	//
	// This works in this driver simply because this driver supports exactly
	// one open handle at a time.  If it supported more, then it would need
	// counting logic to determine when all the reasons for failing Stop/Remove
	// were gone.
	//WdfDeviceSetStaticStopRemove(Device, FALSE);

	// Complete the WDF request.
	WdfRequestComplete(Request, status);
}


NTSTATUS DTMouseDriverCreateDevice(_Inout_ PWDFDEVICE_INIT DeviceInit )
/*++
Routine Description:
    Worker routine called to create a device and its software resources.
Arguments:
    DeviceInit - Pointer to an opaque init structure. Memory for this
                    structure will be freed by the framework when the WdfDeviceCreate
                    succeeds. So don't access the structure after that point.
Return Value:
    NTSTATUS
--*/
{
    WDF_OBJECT_ATTRIBUTES deviceAttributes;
    PDEVICE_CONTEXT deviceContext;
    WDFDEVICE device;
    NTSTATUS status;
	WDF_PNPPOWER_EVENT_CALLBACKS  pnpPowerCallbacks;
//	WDF_FILEOBJECT_CONFIG FileObjectConfig;
	WDF_IO_QUEUE_CONFIG     ioQueueConfig;

    PAGED_CODE();

	WdfDeviceInitSetExclusive(DeviceInit, TRUE);
	WdfDeviceInitSetDeviceType(DeviceInit, FILE_DEVICE_MOUSE);
	
	pnpPowerCallbacks.EvtDeviceSelfManagedIoInit = MouseEvtDeviceSelfManagedIoInit;
	pnpPowerCallbacks.EvtDeviceSelfManagedIoCleanup = MouseEvtDeviceSelfManagedIoCleanup;
	
	// Register the PnP and power callbacks.
	WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);

	TraceEvents(TRACE_LEVEL_INFORMATION,TRACE_QUEUE, "....line=%d ",__LINE__);
	//Register file operation
	//WDF_OBJECT_ATTRIBUTES_INIT(&deviceAttributes);
	//deviceAttributes.SynchronizationScope = WdfSynchronizationScopeNone;
	//WDF_FILEOBJECT_CONFIG_INIT(&FileObjectConfig,
	//	MouseEvtDeviceFileCreate,
	//	MouseEvtFileClose,
	//	MouseEvtFileCleanup // Cleanup
	//);
	//WdfDeviceInitSetFileObjectConfig(DeviceInit,&FileObjectConfig, &deviceAttributes);

	WDF_OBJECT_ATTRIBUTES_INIT(&deviceAttributes);
	WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);
	deviceAttributes.SynchronizationScope = WdfSynchronizationScopeDevice;
    status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);

    if (NT_SUCCESS(status))
	{
        // Get a pointer to the device context structure that we just associated
        // with the device object. We define this structure in the device.h
        // header file. DeviceGetContext is an inline function generated by
        // using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
        // This function will do the type checking and return the device context.
        // If you pass a wrong object handle it will return NULL and assert if
        // run under framework verifier mode.
        deviceContext = DeviceGetContext(device);

        //
        // Initialize the context.
        //
        deviceContext->PrivateDeviceData = 0;

		// Initialize Dpc that we will use for resubmitting pending read
		//deviceContext->dueTime.HighPart = 0;
		//deviceContext->dueTime.LowPart = 100000;
		//KeInitializeTimerEx(&deviceContext->ServiceTme, NotificationTimer);
		//KeInitializeDpc(&deviceContext->ServiceDpc,
		//	DTLM_ServiceDpc, deviceContext);
        // Create a device interface so that applications can find and talk
        // to us.
        status = WdfDeviceCreateDeviceInterface(
            device,
            &GUID_DEVINTERFACE_DTMouseDriver,
            NULL // ReferenceString
            );
        if (NT_SUCCESS(status)) {
            // Initialize the I/O Package and any Queues
            status = DTLM_QueueInitialize(device);

			// Create a new queue to handle IOCTLs that will be forwarded to us from
			// the rawPDO. 
			//
			WDF_IO_QUEUE_CONFIG_INIT(&ioQueueConfig,
				WdfIoQueueDispatchParallel);
			
			// Framework by default creates non-power managed queues for
			// filter drivers.
			ioQueueConfig.EvtIoDeviceControl = DTLM_EvtIoDeviceControlFromRawPdo;
			status = WdfIoQueueCreate(device,
				&ioQueueConfig,
				WDF_NO_OBJECT_ATTRIBUTES,
				&deviceContext->rawPdoQueue
			);
			if (!NT_SUCCESS(status)) {
				KdPrint(("WdfIoQueueCreate failed 0x%x\n", status));
				return status;
			}

			//
			// Create a RAW pdo so we can provide a sideband communication with
			// the application. Please note that not filter drivers desire to
			// produce such a communication and not all of them are contrained
			// by other filter above which prevent communication thru the device
			// interface exposed by the main stack. So use this only if absolutely
			// needed. Also look at the toaster filter driver sample for an alternate
			// approach to providing sideband communication.
			//
			status = DTLM_CreateRawPdo(device, ++InstanceNo);
        }
    }
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_QUEUE, "....line=%d STU=%d ", __LINE__, status);
    return status;
}
